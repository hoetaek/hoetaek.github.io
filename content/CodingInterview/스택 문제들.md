---
title: 스택
draft: false
tags:
---
```table-of-contents
title: 스택 문제들
style: nestedList # TOC style (nestedList|nestedOrderedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```
## 문자열 폭발
문제: https://www.acmicpc.net/problem/9935

### 입력
첫째 줄에 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고, 1,000,000보다 작거나 같다.

둘째 줄에 폭발 문자열이 주어진다. 길이는 1보다 크거나 같고, 36보다 작거나 같다.

두 문자열은 모두 알파벳 소문자와 대문자, 숫자 0, 1, ..., 9로만 이루어져 있다.
### 출력
첫째 줄에 모든 폭발이 끝난 후 남은 문자열을 출력한다.
#### 예제 입력 1
mirkovC4nizCC44
C4
#### 예제 출력 1
mirkovniz
#### 예제 입력2
12ab112ab2ab
12ab
#### 예제 출력2
FRULA
### 풀이
#### 과정
- 마지막으로 들어간 것이 가장 먼저 나온다는 것을 생각해야 한다
- 문제에서는 먼저 크기를 1,000,000까지 입력값이 주어진다고 설명하고 있다. 따라서 O(N)의 시간 복잡도로 접근해야 한다는 것을 알 수 있다
1. **후입선출 (LIFO) 요구**:
	- 스택은 요소를 후입선출 방식으로 처리해야 할 때 이상적입니다. 이 문제에서 폭발 문자열이 나타나면 가장 최근에 추가된 문자를 제거해야 하는데, 이는 스택의 LIFO 원칙과 일치합니다.
2. **중첩 또는 계층 구조**:
	- 중첩된 구조 또는 균형을 맞춰야 하는 문제(예: 괄호 매칭, HTML 태그 검증, 또는 이 폭발 문자열 제거 문제)는 종종 스택 사용이 유리합니다. 요소를 만나면 스택에 푸시하고, 일치하는 요소를 찾으면 올바른 순서로 팝할 수 있기 때문입니다.
3. **작업 취소 (Undo) 연산**:
	- 최근 작업을 취소하거나 백트래킹을 포함하는 문제의 경우, 스택이 유용할 수 있습니다. 이 문제에서는 폭발 문자열을 감지할 때마다 스택에서 해당 문자를 제거하여 추가된 문자를 실질적으로 “취소”합니다.
#### 코드
```python
string = input()
explode = input()
exp_l = len(explode)

stack = []
for i in string:
    stack.append(i)
    if len(stack) >= exp_l and "".join(stack[-exp_l:]) == explode:
        for j in range(exp_l):
            stack.pop()

if stack:
    print(''.join(stack))
else:
    print("FRULA")
```